// Autogenerated IPC server implementation.
// Command:  /home/work/devel/helenos/tools/ipc_generator.py ../../uspace/lib/c/../../../abi/protocol/vfs.txt uspace/lib/c/ipc_vfs.c uspace/lib/c/ipc_vfs.h
// Source timestamp:  2025-12-23 11:26:56.622505

#include "ipc_vfs.h"

#define method_present(ops, method) \
	(offsetof(typeof(*ops), method) + sizeof(ops->method) <= ops->_sizeof && ops->method)

enum vfs_instance_methods {
	_vfs_instance_op_undef,
	_vfs_instance_op_clone,
	_vfs_instance_op_fsprobe,
	_vfs_instance_op_fstypes,
	_vfs_instance_op_mount,
	_vfs_instance_op_open,
	_vfs_instance_op_put,
	_vfs_instance_op_read,
	_vfs_instance_op_rename,
	_vfs_instance_op_resize,
	_vfs_instance_op_stat,
	_vfs_instance_op_statfs,
	_vfs_instance_op_sync,
	_vfs_instance_op_unlink,
	_vfs_instance_op_unmount,
	_vfs_instance_op_wrap_handle,
	_vfs_instance_op_unwrap_handle,
	_vfs_instance_op_walk,
	_vfs_instance_op_write,
};

typedef struct __attribute__((packed)) {
	vfs_fs_probe_info_t info;
} _vfs_instance_fsprobe_outdata_t;

typedef struct __attribute__((packed)) {
	int mpfd;
	service_id_t service_id;
	unsigned flags;
	unsigned instance;
	size_t opts_slice;
	size_t fs_name_slice;
} _vfs_instance_mount_indata_t;

typedef struct __attribute__((packed)) {
	int fd;
	aoff64_t pos;
	size_t buffer_slice;
} _vfs_instance_read_indata_t;

typedef struct __attribute__((packed)) {
	int basefd;
	size_t old_slice;
	size_t new_slice;
} _vfs_instance_rename_indata_t;

typedef struct __attribute__((packed)) {
	vfs_stat_t data;
} _vfs_instance_stat_outdata_t;

typedef struct __attribute__((packed)) {
	vfs_statfs_t data;
} _vfs_instance_statfs_outdata_t;

typedef struct __attribute__((packed)) {
	int fd;
	aoff64_t pos;
	size_t buffer_slice;
} _vfs_instance_write_indata_t;

void vfs_instance_handle_message(vfs_instance_impl_t *self, const ipc_message_t *msg)
{
	vfs_instance_ops_t *ops = *(vfs_instance_ops_t **) self;
	
	bool dropped = msg->flags & IPC_MESSAGE_FLAG_OBJECT_DROPPED;
	bool auto = msg->flags & IPC_MESSAGE_FLAG_AUTOMATIC_MESSAGE;
	bool protocol_error = msg->flags & IPC_MESSAGE_FLAG_PROTOCOL_ERROR;
	
	if (protocol_error)
		return;
	
	if (auto) {
		if (dropped)
			ops->_destroy(self);
		return;
	}
	
	switch (ipcb_get_val_1(msg)) {
	
	// clone(in oldfd: int, in newfd: int, in desc: bool, out outfd: int) -> errno_t
	case _vfs_instance_op_clone:
		{
			// TODO: check message type and detect protocol mismatch
			if (!method_present(ops, clone) {
				ipcb_answer_protocol_error(msg);
				break;
			}
			
			int oldfd = ipcb_get_val2(&msg);
			int newfd = ipcb_get_val3(&msg);
			bool desc = ipcb_get_val4(&msg);
			int outfd = {};
			errno_t rc = ops->clone(self, oldfd, newfd, desc, &outfd);
			ipcb_message_t answer = ipcb_start_answer(&msg, rc);
			ipcb_set_val_1(&answer, outfd);
			ipcb_send_answer(&msg, answer);
			break;
		}
	
	// fsprobe(in service_id: service_id_t, in fs_name: *str, out info: *vfs_fs_probe_info_t) -> errno_t
	case _vfs_instance_op_fsprobe:
		{
			// TODO: check message type and detect protocol mismatch
			if (!method_present(ops, fsprobe) {
				ipcb_answer_protocol_error(msg);
				break;
			}
			
			service_id_t service_id = ipcb_get_val2(&msg);
			size_t fs_name_slice = ipcb_get_val_4(&msg);
			size_t fs_name_len = ipcb_slice_len(fs_name_slice);
			void *fs_name = calloc(fs_name_len, 1);
			if (fs_name == nullptr) {
				ipcb_answer_nomem(msg);
				break;
			}
			
			ipc_blob_read_3(&msg, fs_name, fs_name_slice);
			fs_name[fs_name_len - 1] = '\0';
			
			vfs_fs_probe_info_t info = {};
			errno_t rc = ops->fsprobe(self, service_id, fs_name, &info);
			ipcb_message_t answer = ipcb_start_answer(&msg, rc);
			
			_vfs_instance_fsprobe_outdata_t _outdata = {
				.info = info,
			};
			ipc_blob_write_1(&answer, &_outdata, sizeof(_outdata));
			
			ipcb_send_answer(&msg, answer);
			free(fs_name);
			break;
		}
	
	// fstypes(out fstypes: *data) -> errno_t
	case _vfs_instance_op_fstypes:
		{
			// TODO: check message type and detect protocol mismatch
			if (!method_present(ops, fstypes) {
				ipcb_answer_protocol_error(msg);
				break;
			}
			
			size_t fstypes_slice = ipcb_get_val_3(&msg);
			size_t fstypes_len = ipcb_slice_len(fstypes_slice);
			void *fstypes = calloc(fstypes_len, 1);
			if (fstypes == nullptr) {
				ipcb_answer_nomem(msg);
				break;
			}
			
			ipcb_buffer_t fstypes_obj = ipc_get_obj_2(msg);
			
			errno_t rc = ops->fstypes(self, fstypes, fstypes_len);
			ipcb_buffer_write(fstypes_obj, fstypes_slice, fstypes, fstypes_len);
			ipcb_message_t answer = ipcb_start_answer(&msg, rc);
			ipcb_send_answer(&msg, answer);
			free(fstypes);
			break;
		}
	
	// mount(in mpfd: int, in service_id: service_id_t, in flags: unsigned, in instance: unsigned, in opts: *str, in fs_name: *str, out outfd: int) -> errno_t
	case _vfs_instance_op_mount:
		{
			// TODO: check message type and detect protocol mismatch
			if (!method_present(ops, mount) {
				ipcb_answer_protocol_error(msg);
				break;
			}
			
			_vfs_instance_mount_indata_t _indata;
			ipc_blob_read_2(&msg, &_indata, sizeof(_indata));
			
			size_t opts_len = ipcb_slice_len(_indata.opts_slice);
			void *opts = calloc(opts_len, 1);
			if (opts == nullptr) {
				ipcb_answer_nomem(msg);
				break;
			}
			
			ipc_blob_read_3(&msg, opts, opts_slice);
			opts[opts_len - 1] = '\0';
			
			size_t fs_name_len = ipcb_slice_len(_indata.fs_name_slice);
			void *fs_name = calloc(fs_name_len, 1);
			if (fs_name == nullptr) {
				ipcb_answer_nomem(msg);
				free(opts);
				break;
			}
			
			ipc_blob_read_4(&msg, fs_name, fs_name_slice);
			fs_name[fs_name_len - 1] = '\0';
			
			int outfd = {};
			errno_t rc = ops->mount(self, _indata.mpfd, _indata.service_id, _indata.flags, _indata.instance, opts, fs_name, &outfd);
			ipcb_message_t answer = ipcb_start_answer(&msg, rc);
			ipcb_set_val_1(&answer, outfd);
			ipcb_send_answer(&msg, answer);
			free(opts);
			free(fs_name);
			break;
		}
	
	// open(in fd: int, in mode: int) -> errno_t
	case _vfs_instance_op_open:
		{
			// TODO: check message type and detect protocol mismatch
			if (!method_present(ops, open) {
				ipcb_answer_protocol_error(msg);
				break;
			}
			
			int fd = ipcb_get_val2(&msg);
			int mode = ipcb_get_val3(&msg);
			errno_t rc = ops->open(self, fd, mode);
			ipcb_message_t answer = ipcb_start_answer(&msg, rc);
			ipcb_send_answer(&msg, answer);
			break;
		}
	
	// put(in fd: int) -> errno_t
	case _vfs_instance_op_put:
		{
			// TODO: check message type and detect protocol mismatch
			if (!method_present(ops, put) {
				ipcb_answer_protocol_error(msg);
				break;
			}
			
			int fd = ipcb_get_val2(&msg);
			errno_t rc = ops->put(self, fd);
			ipcb_message_t answer = ipcb_start_answer(&msg, rc);
			ipcb_send_answer(&msg, answer);
			break;
		}
	
	// read(in fd: int, in64 pos: aoff64_t, out buffer: *data, out read: size_t) -> errno_t
	case _vfs_instance_op_read:
		{
			// TODO: check message type and detect protocol mismatch
			if (!method_present(ops, read) {
				ipcb_answer_protocol_error(msg);
				break;
			}
			
			_vfs_instance_read_indata_t _indata;
			ipc_blob_read_2(&msg, &_indata, sizeof(_indata));
			
			size_t buffer_len = ipcb_slice_len(_indata.buffer_slice);
			void *buffer = calloc(buffer_len, 1);
			if (buffer == nullptr) {
				ipcb_answer_nomem(msg);
				break;
			}
			
			ipcb_buffer_t buffer_obj = ipc_get_obj_3(msg);
			
			size_t read = {};
			errno_t rc = ops->read(self, _indata.fd, _indata.pos, buffer, buffer_len, &read);
			ipcb_buffer_write(buffer_obj, _indata.buffer_slice, buffer, buffer_len);
			ipcb_message_t answer = ipcb_start_answer(&msg, rc);
			ipcb_set_val_1(&answer, read);
			ipcb_send_answer(&msg, answer);
			free(buffer);
			break;
		}
	
	// rename(in basefd: int, in old: *str, in new: *str) -> errno_t
	case _vfs_instance_op_rename:
		{
			// TODO: check message type and detect protocol mismatch
			if (!method_present(ops, rename) {
				ipcb_answer_protocol_error(msg);
				break;
			}
			
			_vfs_instance_rename_indata_t _indata;
			ipc_blob_read_2(&msg, &_indata, sizeof(_indata));
			
			size_t old_len = ipcb_slice_len(_indata.old_slice);
			void *old = calloc(old_len, 1);
			if (old == nullptr) {
				ipcb_answer_nomem(msg);
				break;
			}
			
			ipc_blob_read_3(&msg, old, old_slice);
			old[old_len - 1] = '\0';
			
			size_t new_len = ipcb_slice_len(_indata.new_slice);
			void *new = calloc(new_len, 1);
			if (new == nullptr) {
				ipcb_answer_nomem(msg);
				free(old);
				break;
			}
			
			ipc_blob_read_4(&msg, new, new_slice);
			new[new_len - 1] = '\0';
			
			errno_t rc = ops->rename(self, _indata.basefd, old, new);
			ipcb_message_t answer = ipcb_start_answer(&msg, rc);
			ipcb_send_answer(&msg, answer);
			free(old);
			free(new);
			break;
		}
	
	// resize(in fd: int, in64 size: int64_t) -> errno_t
	case _vfs_instance_op_resize:
		{
			// TODO: check message type and detect protocol mismatch
			if (!method_present(ops, resize) {
				ipcb_answer_protocol_error(msg);
				break;
			}
			
			int fd = ipcb_get_val2(&msg);
			int64_t size = ipcb_get_val64_3(&msg);
			errno_t rc = ops->resize(self, fd, size);
			ipcb_message_t answer = ipcb_start_answer(&msg, rc);
			ipcb_send_answer(&msg, answer);
			break;
		}
	
	// stat(in fd: int, out data: *vfs_stat_t) -> errno_t
	case _vfs_instance_op_stat:
		{
			// TODO: check message type and detect protocol mismatch
			if (!method_present(ops, stat) {
				ipcb_answer_protocol_error(msg);
				break;
			}
			
			int fd = ipcb_get_val2(&msg);
			vfs_stat_t data = {};
			errno_t rc = ops->stat(self, fd, &data);
			ipcb_message_t answer = ipcb_start_answer(&msg, rc);
			
			_vfs_instance_stat_outdata_t _outdata = {
				.data = data,
			};
			ipc_blob_write_1(&answer, &_outdata, sizeof(_outdata));
			
			ipcb_send_answer(&msg, answer);
			break;
		}
	
	// statfs(in fd: int, out data: *vfs_statfs_t) -> errno_t
	case _vfs_instance_op_statfs:
		{
			// TODO: check message type and detect protocol mismatch
			if (!method_present(ops, statfs) {
				ipcb_answer_protocol_error(msg);
				break;
			}
			
			int fd = ipcb_get_val2(&msg);
			vfs_statfs_t data = {};
			errno_t rc = ops->statfs(self, fd, &data);
			ipcb_message_t answer = ipcb_start_answer(&msg, rc);
			
			_vfs_instance_statfs_outdata_t _outdata = {
				.data = data,
			};
			ipc_blob_write_1(&answer, &_outdata, sizeof(_outdata));
			
			ipcb_send_answer(&msg, answer);
			break;
		}
	
	// sync(in fd: int) -> errno_t
	case _vfs_instance_op_sync:
		{
			// TODO: check message type and detect protocol mismatch
			if (!method_present(ops, sync) {
				ipcb_answer_protocol_error(msg);
				break;
			}
			
			int fd = ipcb_get_val2(&msg);
			errno_t rc = ops->sync(self, fd);
			ipcb_message_t answer = ipcb_start_answer(&msg, rc);
			ipcb_send_answer(&msg, answer);
			break;
		}
	
	// unlink(in parentfd: int, in expectfd: int, in path: *str) -> errno_t
	case _vfs_instance_op_unlink:
		{
			// TODO: check message type and detect protocol mismatch
			if (!method_present(ops, unlink) {
				ipcb_answer_protocol_error(msg);
				break;
			}
			
			int parentfd = ipcb_get_val2(&msg);
			int expectfd = ipcb_get_val3(&msg);
			size_t path_slice = ipcb_get_val_5(&msg);
			size_t path_len = ipcb_slice_len(path_slice);
			void *path = calloc(path_len, 1);
			if (path == nullptr) {
				ipcb_answer_nomem(msg);
				break;
			}
			
			ipc_blob_read_4(&msg, path, path_slice);
			path[path_len - 1] = '\0';
			
			errno_t rc = ops->unlink(self, parentfd, expectfd, path);
			ipcb_message_t answer = ipcb_start_answer(&msg, rc);
			ipcb_send_answer(&msg, answer);
			free(path);
			break;
		}
	
	// unmount(in mpfd: int) -> errno_t
	case _vfs_instance_op_unmount:
		{
			// TODO: check message type and detect protocol mismatch
			if (!method_present(ops, unmount) {
				ipcb_answer_protocol_error(msg);
				break;
			}
			
			int mpfd = ipcb_get_val2(&msg);
			errno_t rc = ops->unmount(self, mpfd);
			ipcb_message_t answer = ipcb_start_answer(&msg, rc);
			ipcb_send_answer(&msg, answer);
			break;
		}
	
	// wrap_handle(in fd: int, out obj handle: *vfs_wrapped_handle) -> errno_t
	case _vfs_instance_op_wrap_handle:
		{
			// TODO: check message type and detect protocol mismatch
			if (!method_present(ops, wrap_handle) {
				ipcb_answer_protocol_error(msg);
				break;
			}
			
			int fd = ipcb_get_val2(&msg);
			vfs_wrapped_handle handle = {};
			errno_t rc = ops->wrap_handle(self, fd, &handle);
			ipcb_message_t answer = ipcb_start_answer(&msg, rc);
			ipcb_set_obj_1(&answer, handle);
			ipcb_send_answer(&msg, answer);
			break;
		}
	
	// unwrap_handle(in obj handle: *vfs_wrapped_handle, in high_fd: bool, out fd: int) -> errno_t
	case _vfs_instance_op_unwrap_handle:
		{
			// TODO: check message type and detect protocol mismatch
			if (!method_present(ops, unwrap_handle) {
				ipcb_answer_protocol_error(msg);
				break;
			}
			
			vfs_wrapped_handle handle = ipcb_get_obj2(&msg);
			bool high_fd = ipcb_get_val3(&msg);
			vfs_wrapped_handle handle = _indata.handle;
			int fd = {};
			errno_t rc = ops->unwrap_handle(self, &handle, high_fd, &fd);
			ipcb_message_t answer = ipcb_start_answer(&msg, rc);
			ipcb_set_val_1(&answer, fd);
			ipcb_send_answer(&msg, answer);
			break;
		}
	
	// walk(in parentfd: int, in flags: int, in path: *str, out fd: int) -> errno_t
	case _vfs_instance_op_walk:
		{
			// TODO: check message type and detect protocol mismatch
			if (!method_present(ops, walk) {
				ipcb_answer_protocol_error(msg);
				break;
			}
			
			int parentfd = ipcb_get_val2(&msg);
			int flags = ipcb_get_val3(&msg);
			size_t path_slice = ipcb_get_val_5(&msg);
			size_t path_len = ipcb_slice_len(path_slice);
			void *path = calloc(path_len, 1);
			if (path == nullptr) {
				ipcb_answer_nomem(msg);
				break;
			}
			
			ipc_blob_read_4(&msg, path, path_slice);
			path[path_len - 1] = '\0';
			
			int fd = {};
			errno_t rc = ops->walk(self, parentfd, flags, path, &fd);
			ipcb_message_t answer = ipcb_start_answer(&msg, rc);
			ipcb_set_val_1(&answer, fd);
			ipcb_send_answer(&msg, answer);
			free(path);
			break;
		}
	
	// write(in fd: int, in64 pos: aoff64_t, in buffer: *data, out written: size_t) -> errno_t
	case _vfs_instance_op_write:
		{
			// TODO: check message type and detect protocol mismatch
			if (!method_present(ops, write) {
				ipcb_answer_protocol_error(msg);
				break;
			}
			
			_vfs_instance_write_indata_t _indata;
			ipc_blob_read_2(&msg, &_indata, sizeof(_indata));
			
			size_t buffer_len = ipcb_slice_len(_indata.buffer_slice);
			void *buffer = calloc(buffer_len, 1);
			if (buffer == nullptr) {
				ipcb_answer_nomem(msg);
				break;
			}
			
			ipc_blob_read_3(&msg, buffer, buffer_slice);
			
			size_t written = {};
			errno_t rc = ops->write(self, _indata.fd, _indata.pos, buffer, buffer_len, &written);
			ipcb_message_t answer = ipcb_start_answer(&msg, rc);
			ipcb_set_val_1(&answer, written);
			ipcb_send_answer(&msg, answer);
			free(buffer);
			break;
		}
	default:
		ipcb_answer_protocol_error(msg);
	}
	
	if (dropped)
		ops->_destroy(self);
}

errno_t vfs_instance_clone(vfs_instance_t *self, int oldfd, int newfd, bool desc, int *outfd)
{
	ipc_message_t msg = {};
}

errno_t vfs_instance_fsprobe(vfs_instance_t *self, service_id_t service_id, const char *fs_name, vfs_fs_probe_info_t *info)
{
	size_t fs_name_size = strlen(fs_name) + 1;
	ipc_blob_t *fs_name_blob = ipc_blob_create(fs_name, fs_name_size);
}

errno_t vfs_instance_fsprobe_raw(vfs_instance_t *self, service_id_t service_id, ipc_blob_t *fs_name, size_t fs_name_slice, vfs_fs_probe_info_t *info)
{
	ipc_message_t msg = {};
}

errno_t vfs_instance_fstypes(vfs_instance_t *self, void *fstypes, size_t fstypes_size)
{
	ipc_buffer_t *fstypes_buffer = ipc_buffer_create(fstypes_size);
}

errno_t vfs_instance_fstypes_raw(vfs_instance_t *self, ipc_buffer_t *fstypes, size_t fstypes_slice)
{
	ipc_message_t msg = {};
}

errno_t vfs_instance_mount(vfs_instance_t *self, int mpfd, service_id_t service_id, unsigned flags, unsigned instance, const char *opts, const char *fs_name, int *outfd)
{
	size_t opts_size = strlen(opts) + 1;
	ipc_blob_t *opts_blob = ipc_blob_create(opts, opts_size);
	size_t fs_name_size = strlen(fs_name) + 1;
	ipc_blob_t *fs_name_blob = ipc_blob_create(fs_name, fs_name_size);
}

errno_t vfs_instance_mount_raw(vfs_instance_t *self, int mpfd, service_id_t service_id, unsigned flags, unsigned instance, ipc_blob_t *opts, size_t opts_slice, ipc_blob_t *fs_name, size_t fs_name_slice, int *outfd)
{
	ipc_message_t msg = {};
	_vfs_instance_mount_indata_t _indata = {
		.mpfd = mpfd,
		.service_id = service_id,
		.flags = flags,
		.instance = instance,
		.opts_slice = opts_slice,
		.fs_name_slice = fs_name_slice,
	};
	
	ipc_blob_t *_indata_blob = ipc_blob_create(&_indata, sizeof(_indata));
	ipcb_message_set_obj_2(&msg, _indata_blob);
}

errno_t vfs_instance_open(vfs_instance_t *self, int fd, int mode)
{
	ipc_message_t msg = {};
}

errno_t vfs_instance_put(vfs_instance_t *self, int fd)
{
	ipc_message_t msg = {};
}

errno_t vfs_instance_read(vfs_instance_t *self, int fd, aoff64_t pos, void *buffer, size_t buffer_size, size_t *read)
{
	ipc_buffer_t *buffer_buffer = ipc_buffer_create(buffer_size);
}

errno_t vfs_instance_read_raw(vfs_instance_t *self, int fd, aoff64_t pos, ipc_buffer_t *buffer, size_t buffer_slice, size_t *read)
{
	ipc_message_t msg = {};
	_vfs_instance_read_indata_t _indata = {
		.fd = fd,
		.pos = pos,
		.buffer_slice = buffer_slice,
	};
	
	ipc_blob_t *_indata_blob = ipc_blob_create(&_indata, sizeof(_indata));
	ipcb_message_set_obj_2(&msg, _indata_blob);
}

errno_t vfs_instance_rename(vfs_instance_t *self, int basefd, const char *old, const char *new)
{
	size_t old_size = strlen(old) + 1;
	ipc_blob_t *old_blob = ipc_blob_create(old, old_size);
	size_t new_size = strlen(new) + 1;
	ipc_blob_t *new_blob = ipc_blob_create(new, new_size);
}

errno_t vfs_instance_rename_raw(vfs_instance_t *self, int basefd, ipc_blob_t *old, size_t old_slice, ipc_blob_t *new, size_t new_slice)
{
	ipc_message_t msg = {};
	_vfs_instance_rename_indata_t _indata = {
		.basefd = basefd,
		.old_slice = old_slice,
		.new_slice = new_slice,
	};
	
	ipc_blob_t *_indata_blob = ipc_blob_create(&_indata, sizeof(_indata));
	ipcb_message_set_obj_2(&msg, _indata_blob);
}

errno_t vfs_instance_resize(vfs_instance_t *self, int fd, int64_t size)
{
	ipc_message_t msg = {};
}

errno_t vfs_instance_stat(vfs_instance_t *self, int fd, vfs_stat_t *data)
{
	ipc_message_t msg = {};
}

errno_t vfs_instance_statfs(vfs_instance_t *self, int fd, vfs_statfs_t *data)
{
	ipc_message_t msg = {};
}

errno_t vfs_instance_sync(vfs_instance_t *self, int fd)
{
	ipc_message_t msg = {};
}

errno_t vfs_instance_unlink(vfs_instance_t *self, int parentfd, int expectfd, const char *path)
{
	size_t path_size = strlen(path) + 1;
	ipc_blob_t *path_blob = ipc_blob_create(path, path_size);
}

errno_t vfs_instance_unlink_raw(vfs_instance_t *self, int parentfd, int expectfd, ipc_blob_t *path, size_t path_slice)
{
	ipc_message_t msg = {};
}

errno_t vfs_instance_unmount(vfs_instance_t *self, int mpfd)
{
	ipc_message_t msg = {};
}

errno_t vfs_instance_wrap_handle(vfs_instance_t *self, int fd, vfs_wrapped_handle_t **handle)
{
	ipc_message_t msg = {};
}

errno_t vfs_instance_unwrap_handle(vfs_instance_t *self, vfs_wrapped_handle_t *handle, bool high_fd, int *fd)
{
	ipc_message_t msg = {};
}

errno_t vfs_instance_walk(vfs_instance_t *self, int parentfd, int flags, const char *path, int *fd)
{
	size_t path_size = strlen(path) + 1;
	ipc_blob_t *path_blob = ipc_blob_create(path, path_size);
}

errno_t vfs_instance_walk_raw(vfs_instance_t *self, int parentfd, int flags, ipc_blob_t *path, size_t path_slice, int *fd)
{
	ipc_message_t msg = {};
}

errno_t vfs_instance_write(vfs_instance_t *self, int fd, aoff64_t pos, const void *buffer, size_t buffer_size, size_t *written)
{
	ipc_blob_t *buffer_blob = ipc_blob_create(buffer, buffer_size);
}

errno_t vfs_instance_write_raw(vfs_instance_t *self, int fd, aoff64_t pos, ipc_blob_t *buffer, size_t buffer_slice, size_t *written)
{
	ipc_message_t msg = {};
	_vfs_instance_write_indata_t _indata = {
		.fd = fd,
		.pos = pos,
		.buffer_slice = buffer_slice,
	};
	
	ipc_blob_t *_indata_blob = ipc_blob_create(&_indata, sizeof(_indata));
	ipcb_message_set_obj_2(&msg, _indata_blob);
}
