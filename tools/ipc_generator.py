#!/usr/bin/env python3

import sys
import os
from datetime import datetime

def parse_ipc_file(content):
    """Parse IPC definition file into structured blocks."""
    # Remove all newlines and extra whitespace - treat as continuous stream
    content = " ".join(content.split())

    blocks = []
    i = 0

    while i < len(content):
        # Find block start
        brace_pos = content.find("{", i)
        if brace_pos == -1:
            break

        # Extract block header (everything before {)
        header = content[i:brace_pos].strip()

        # Find closing brace (no nesting)
        close_brace = content.find("}", brace_pos)
        if close_brace == -1:
            break

        # Extract block content (between braces)
        block_content = content[brace_pos + 1 : close_brace].strip()

        blocks.append({"header": header, "content": block_content})

        i = close_brace + 1

    return blocks


def parse_block(block_content):
    """Parse block content into methods by splitting on semicolons."""
    # Split by semicolon
    statements = [s.strip() for s in block_content.split(";") if s.strip()]

    methods = {}
    for stmt in statements:
        # Split by comma to get fields
        fields = [f.strip() for f in stmt.split(",")]

        # Split each field by whitespace
        parsed_fields = []
        for field in fields:
            parts = field.split()
            parsed_fields.append(parts)

        method_name = parsed_fields[0][0]

        methods[method_name] = parsed_fields

    return methods


# Main program
if len(sys.argv) != 2:
    print(f"Usage: {sys.argv[0]} <input_file>", file=sys.stderr)
    sys.exit(1)

with open(sys.argv[1], "r") as f:
    content = f.read()

data = {}

for block in parse_ipc_file(content):
    header_parts = block["header"].split()
    block_type = header_parts[0]
    block_name = header_parts[1]

    if block_type not in data:
        data[block_type] = {}

    data[block_type][block_name] = parse_block(block["content"])


def impl_name(server, method):
    if method in data["server"][server]:
        return data["server"][server][method][1][0]
    else:
        return data["server"][server]["@default"][1][0].replace("*", method)


def enum_name(server, method):
    enum_prefix = data["server"][server]["@enum_prefix"][1][0]
    return f"{enum_prefix}{method.upper()}"


args = {}

for obj in data["obj"]:
    args[obj] = {}
    for method in data["obj"][obj]:
        args[obj][method] = []
        for arg in data["obj"][obj][method][2:]:
            argdef = {}
            argdef["name"] = arg[-1]
            arg = arg[:-1]
            argdef["indirect"] = argdef["name"].startswith("*")
            if argdef["indirect"]:
                argdef["name"] = argdef["name"][1:]

            if len(arg) > 0:
                argdef["in"] = arg[0] == "in" or arg[0] == "in64" or arg[0] == "inout" or arg[0] == "inout64"
                argdef["out"] = arg[0] == "out" or arg[0] == "out64" or arg[0] == "inout" or arg[0] == "inout64"
                argdef["wide"] = arg[0] == "in64" or arg[0] == "out64" or arg[0] == "inout64"
                if argdef["in"] or argdef["out"]:
                    arg = arg[1:]

            if not argdef["out"]:
                argdef["in"] = True

            if len(arg) > 0:
                argdef["object"] = arg[0] == "obj"
                if argdef["object"]:
                    arg = arg[1:]

            if len(arg) > 0:
                argdef["type"] = arg[0]
            else:
                argdef["type"] = None

            args[obj][method].append(argdef)

print("// Autogenerated IPC server implementation.")
print("// Command: ", *sys.argv)
print("// Source timestamp: ", datetime.fromtimestamp(os.path.getmtime(sys.argv[1])))
print()

print("#include <stddef.h>")
print("#include <stdlib.h>")
print("#include \"ipc_shim.h\"")

print()
for server in data["server"]:

    print(f"void {server}_handle_message(const ipcb_message_t *msg, {server} *instance)")
    print("{")

    print("\tswitch (ipcb_get_val_1(msg)) {")

    for method in data["obj"][server]:
        arg = args[server][method]
        ret = data["obj"][server][method][1][0]

        # 0: return endpoint
        # 1: method number
        # four spare arguments for method args
        #
        # if we can put all arguments in directly, we do so, otherwise we go
        # with single ipc_blob_t for all args

        slots_needed_in = 0
        indirect_slot_in = 0
        slots_needed_out = 0
        indirect_slot_out = 0

        for a in arg:
            if a["in"]:
                if a["indirect"] and a["type"] is not None and a["type"] != "str":
                    indirect_slot_in = 1
                elif a["wide"] or a["type"] == "str" or (a["indirect"] and a["type"] is None):
                    slots_needed_in += 2
                else:
                    slots_needed_in += 1
            if a["out"]:
                if a["indirect"] and a["type"] is not None and a["type"] != "str":
                    indirect_slot_out = 1
                elif a["wide"]:
                    slots_needed_out += 2
                elif a["type"] == "str" or (a["indirect"] and a["type"] is None):
                    slots_needed_in += 2 # yes, it's meant to be "in"
                else:
                    slots_needed_out += 1

        merge_inputs = (slots_needed_in + indirect_slot_in) > 4
        merge_outputs = (slots_needed_out + indirect_slot_out) > 4

        print()
        print(f"\t/* {method} :: {arg} */")
        print()

        print(f"\tcase {enum_name(server, method)}: // {impl_name(server, method)}")
        print("\t{")

        print("\t\t// TODO: check message type and detect protocol mismatch")

        arg_idx = 2

        if merge_inputs or indirect_slot_in > 0:
            print("\t\tstruct __attribute__((packed)) {")
            for a in arg:
                if a["in"]:
                    if a["indirect"] and (a["type"] == "str" or a["type"] is None) and merge_inputs:
                        print(f"\t\t\tsize_t {a['name']}_slice;")
                    elif (a["indirect"] and a["type"] is not None) or (not a["indirect"] and merge_inputs):
                        print(f"\t\t\t{a['type']} {a['name']};")
                elif (a["type"] == "str" or a["type"] is None) and merge_inputs:
                    print(f"\t\t\tsize_t {a['name']}_slice;")
            print("\t\t} _indata;")
            print()
            print(f"\t\tipc_blob_read_{arg_idx}(&msg, &_indata, sizeof(_indata));")
            print()
            arg_idx += 1

        if merge_inputs:
            indata_prefix="_indata."
        else:
            indata_prefix=""

        allocs = []

        for a in arg:
            if a["type"] == "str" or a["type"] is None:
                if not merge_inputs:
                    print(f"\t\tsize_t {a['name']}_slice = ipcb_get_val_{arg_idx}(&msg);")
                    arg_idx += 1

                print(f"\t\tsize_t {a['name']}_len = ipcb_slice_len({indata_prefix}{a['name']}_slice);")
                print(f"\t\tvoid *{a['name']} = calloc({a['name']}_len, 1);")
                print(f"\t\tif ({a['name']} == nullptr) {{")
                print("\t\t\tipcb_answer_nomem(msg);")
                for alloc in allocs:
                    print(f"\t\t\tfree({alloc});")
                print("\t\t\treturn;")
                print("\t\t}")
                allocs += [a['name']]

                print()

                if a["in"]:
                    print(f"\t\tipc_blob_read_{arg_idx}(&msg, {a['name']}, {a['name']}_slice);")
                    if a["type"] == "str":
                        print(f"\t\t{a['name']}[{a['name']}_len - 1] = '\\0';")
                else:
                    print(f"\t\tipcb_buffer_t {a['name']}_obj = ipc_get_obj_{arg_idx}(msg);")

                print()
                arg_idx += 1
            elif a["in"]:
                if a["object"]:
                    print(f"\t\t{a['type']} {a['name']} = ipcb_get_obj{arg_idx}(&msg);")
                    arg_idx += 1
                elif (not a["indirect"] and a["wide"] and not merge_inputs):
                    print(f"\t\t{a['type']} {a['name']} = ipcb_get_val64_{arg_idx}(&msg);")
                    arg_idx += 2
                elif (not a["indirect"] and not merge_inputs):
                    print(f"\t\t{a['type']} {a['name']} = ipcb_get_val{arg_idx}(&msg);")
                    arg_idx += 1

        for a in arg:
            if a["out"] and a["type"] != "str" and a["type"] is not None:
                print(f"\t\t{a['type']} {a['name']};")
            if a["in"] and a["indirect"] and a['type'] is not None and a['type'] != "str":
                print(f"\t\t{a['type']} {a['name']} = _indata.{a['name']};")

        print(f"\t\t{ret} rc = {impl_name(server, method)}(", end="")

        arglist = []

        for a in arg:
            if a["indirect"] and a["type"] is None:
                arglist += [a['name'], f"{a['name']}_len"]
            elif a["indirect"] and a["type"] == "str":
                arglist += [a['name']]
            elif a["out"] or a["indirect"]:
                arglist += ["&" + a['name']]
            else:
                arglist += [indata_prefix + a['name']]

        print(*arglist, sep=", ", end=");\n")

        for a in arg:
            if a["out"] and a["indirect"] and (a["type"] is None or a["type"] == "str"):
                print(f"\t\tipcb_buffer_write({a["name"]}_obj, {indata_prefix + a["name"]}_slice, {a["name"]}, {a["name"]}_len);")

        print("\t\tipcb_message_t answer = ipcb_start_answer(&msg, rc);")

        arg_idx = 1

        if merge_outputs or indirect_slot_out > 0:
            print()
            print("\t\tstruct __attribute__((packed)) {")
            for a in arg:
                if a["out"]:
                    if a["type"] == "str":
                        print(f"\t\t\tsize_t {a['name']}_len;")
                    elif (a["indirect"] and a["type"] is not None) or (not a["indirect"] and merge_inputs):
                        print(f"\t\t\t{a['type']} {a['name']};")
            print("\t\t} _outdata = {")
            for a in arg:
                if a["out"]:
                    if a["type"] == "str":
                        print(f"\t\t\t.{a['name']}_len = {a['name']}_len,")
                    elif (a["indirect"] and a["type"] is not None) or (not a["indirect"] and merge_inputs):
                        print(f"\t\t\t.{a['name']} = {a['name']},")
            print("\t\t};")

            print(f"\t\tipc_blob_write_{arg_idx}(&answer, &_outdata, sizeof(_outdata));")
            arg_idx += 1
            print()

        if not merge_outputs:
            for a in arg:
                if a["out"]:
                    if not a["indirect"]:
                        print(f"\t\tipcb_set_val_{arg_idx}(&answer, {a['name']});")
                        arg_idx += 1
                    elif a["type"] == "str":
                        print(f"\t\tipcb_set_val_{arg_idx}(&answer, {a['name']}_len);")
                        arg_idx += 1

        print("\t\tipcb_send_answer(&msg, answer);")

        for alloc in allocs:
            print(f"\t\tfree({alloc});")

        print("\t\treturn;")
        print("\t}")

    print("\tdefault:")
    print("\t\tipcb_answer_protocol_error(msg);")
    print("\t}")
    print("}")
