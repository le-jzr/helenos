#!/usr/bin/env python3

# Unimportant parts generated by Claude Sonnet 3.5 LLM.

import sys

def parse_ipc_file(content):
    """Parse IPC definition file into structured blocks."""
    # Remove all newlines and extra whitespace - treat as continuous stream
    content = ' '.join(content.split())
    
    blocks = []
    i = 0
    
    while i < len(content):
        # Find block start
        brace_pos = content.find('{', i)
        if brace_pos == -1:
            break
        
        # Extract block header (everything before {)
        header = content[i:brace_pos].strip()
        
        # Find closing brace (no nesting)
        close_brace = content.find('}', brace_pos)
        if close_brace == -1:
            break
        
        # Extract block content (between braces)
        block_content = content[brace_pos + 1:close_brace].strip()
        
        blocks.append({
            'header': header,
            'content': block_content
        })
        
        i = close_brace + 1
    
    return blocks

def parse_block(block_content):
    """Parse block content into methods by splitting on semicolons."""
    # Split by semicolon
    statements = [s.strip() for s in block_content.split(';') if s.strip()]
    
    methods = {}
    for stmt in statements:
        # Split by comma to get fields
        fields = [f.strip() for f in stmt.split(',')]
        
        # Split each field by whitespace
        parsed_fields = []
        for field in fields:
            parts = field.split()
            parsed_fields.append(parts)
        
        method_name = parsed_fields[0][0]
        
        methods[method_name] = parsed_fields
    
    return methods

# Main execution
if len(sys.argv) != 2:
    print("Usage: python script.py <input_file>", file=sys.stderr)
    sys.exit(1)

with open(sys.argv[1], 'r') as f:
    content = f.read()

data = {}

for block in parse_ipc_file(content):
    header_parts = block['header'].split()
    block_type = header_parts[0]
    block_name = header_parts[1]
    
    if not block_type in data:
    	data[block_type] = {}
    
    data[block_type][block_name] = parse_block(block['content'])

def impl_name(server, method):
    if method in data['server'][server]:
        return data['server'][server][method][1][0]
    else:
    	return data['server'][server]['@default'][1][0].replace('*', method)

def enum_name(server, method):
    enum_prefix = data['server'][server]['@enum_prefix'][1][0]
    return f"{enum_prefix}{method.upper()}"

args = {}

for obj in data['obj']:
    args[obj] = {}
    for method in data['obj'][obj]:
        args[obj][method] = []
        for arg in data['obj'][obj][method][2:]:
            argdef = {}
            argdef['name'] = arg[-1]
            arg = arg[:-1]
            argdef['indirect'] = argdef['name'].startswith('*')
            if argdef['indirect']:
            	argdef['name'] = argdef['name'][1:]
            
            argdef['in'] = arg[0] == 'in' or arg[0] == 'in64'
            argdef['out'] = arg[0] == 'out' or arg[0] == 'out64'
            argdef['wide'] = arg[0] == 'in64' or arg[0] == 'out64'
            if argdef['in'] or argdef['out']:
            	arg = arg[1:]
            
            if len(arg) == 1:
            	argdef['type'] = arg[0]
            else:
            	argdef['type'] = None
            
            args[obj][method].append(argdef)
        
print(f"{args}")

for server in data['server']:
    for method in data['obj'][server]:
    	print(f"{method} :: {data['obj'][server][method]}")
    	    
    	print(f"{enum_name(server, method)}")
    	
    	
    	
    	
    	    

def generate_code(block_type, block_name, methods):
    """Generate code based on parsed methods."""
    print(f"// Block: {block_type} {block_name}")
    print()
    
    for method in methods:
        if not method['fields']:
            continue
           
        method_name = method['fields'][0][0]
        
        print(f"  // Fields: {method['fields']}")
        print(f"  // Method: {method_name}")
        print(f"  // Raw: {method['raw']}")
        
        # Generate parameter list
        params = []
        for field in method['fields'][1:]:
            if len(field) >= 2:
                param_type = ' '.join(field[:-1])
                param_name = field[-1]
                params.append(f"{param_type} {param_name}")
        
        print(f"  // Parameters: {', '.join(params)}")
        print()
