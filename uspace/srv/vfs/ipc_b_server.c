// Autogenerated IPC server implementation.
// Command:  /home/jzr/helenos/tools/ipc_generator.py ipc_b_methods.txt
// Source timestamp:  2025-12-12 18:44:07.863230

#include <stddef.h>
#include <stdlib.h>
#include <ipc_b.h>
#include "ipc_shim.h"

enum vfs_instance_methods {
	_vfs_instance_op_undef,
	_vfs_instance_op_clone,
	_vfs_instance_op_fsprobe,
	_vfs_instance_op_fstypes,
	_vfs_instance_op_mount,
	_vfs_instance_op_open,
	_vfs_instance_op_put,
	_vfs_instance_op_read,
	_vfs_instance_op_rename,
	_vfs_instance_op_resize,
	_vfs_instance_op_stat,
	_vfs_instance_op_statfs,
	_vfs_instance_op_sync,
	_vfs_instance_op_unlink,
	_vfs_instance_op_unmount,
	_vfs_instance_op_wrap_handle,
	_vfs_instance_op_unwrap_handle,
	_vfs_instance_op_walk,
	_vfs_instance_op_write,
};

struct vfs_instance_ops {
	void (*_handle_message)(vfs_instance_impl_t *self, const ipc_message_t *msg);
	errno_t (*clone)(vfs_instance_impl_t *self, int oldfd, int newfd, bool desc, int *outfd);
	errno_t (*fsprobe)(vfs_instance_impl_t *self, service_id_t service_id, const char *fs_name, vfs_fs_probe_info_t *info);
	errno_t (*fstypes)(vfs_instance_impl_t *self, ipc_buffer_t *fstypes, size_t fstypes_len);
	errno_t (*mount)(vfs_instance_impl_t *self, int mpfd, service_id_t service_id, unsigned flags, unsigned instance, const char *opts, const char *fs_name, int *outfd);
	errno_t (*open)(vfs_instance_impl_t *self, int fd, int mode);
	errno_t (*put)(vfs_instance_impl_t *self, int fd);
	errno_t (*read)(vfs_instance_impl_t *self, int fd, aoff64_t pos, ipc_buffer_t *buffer, size_t buffer_len, size_t *read);
	errno_t (*rename)(vfs_instance_impl_t *self, int basefd, const char *old, const char *new);
	errno_t (*resize)(vfs_instance_impl_t *self, int fd, int64_t size);
	errno_t (*stat)(vfs_instance_impl_t *self, int fd, vfs_stat_t *data);
	errno_t (*statfs)(vfs_instance_impl_t *self, int fd, vfs_statfs_t *data);
	errno_t (*sync)(vfs_instance_impl_t *self, int fd);
	errno_t (*unlink)(vfs_instance_impl_t *self, int parentfd, int expectfd, const char *path);
	errno_t (*unmount)(vfs_instance_impl_t *self, int mpfd);
	errno_t (*wrap_handle)(vfs_instance_impl_t *self, int fd, vfs_wrapped_handle_impl_t **handle);
	errno_t (*unwrap_handle)(vfs_instance_impl_t *self, vfs_wrapped_handle_impl_t *handle, bool high_fd, int *fd);
	errno_t (*walk)(vfs_instance_impl_t *self, int parentfd, int flags, const char *path, int *fd);
	errno_t (*write)(vfs_instance_impl_t *self, int fd, aoff64_t pos, const ipc_blob_t *buffer, size_t buffer_len, size_t *written);
};

void vfs_instance_handle_message(vfs_instance_impl_t *self, const ipc_message_t *msg)
{
	switch (ipcb_get_val_1(msg)) {

	/* clone :: [{'name': 'oldfd', 'indirect': False, 'in': True, 'out': False, 'wide': False, 'object': False, 'type': 'int'}, {'name': 'newfd', 'indirect': False, 'in': True, 'out': False, 'wide': False, 'object': False, 'type': 'int'}, {'name': 'desc', 'indirect': False, 'in': True, 'out': False, 'wide': False, 'object': False, 'type': 'bool'}, {'name': 'outfd', 'indirect': False, 'in': False, 'out': True, 'wide': False, 'object': False, 'type': 'int'}] */

	case _vfs_instance_op_clone:
	{
		// TODO: check message type and detect protocol mismatch
			if (offsetof(typeof(*ops), clone) + sizeof(void *) > ops_size || !ops->clone) {
				ipcb_answer_protocol_error(msg);
				return;
			}

		int oldfd = ipcb_get_val2(&msg);
		int newfd = ipcb_get_val3(&msg);
		bool desc = ipcb_get_val4(&msg);
		int outfd;
		errno_t rc = ops->clone(self, oldfd, newfd, desc, &outfd);
		ipcb_message_t answer = ipcb_start_answer(&msg, rc);
		ipcb_set_val_1(&answer, outfd);
		ipcb_send_answer(&msg, answer);
		return;
	}

	/* fsprobe :: [{'name': 'service_id', 'indirect': False, 'in': True, 'out': False, 'wide': False, 'object': False, 'type': 'service_id_t'}, {'name': 'fs_name', 'indirect': True, 'in': True, 'out': False, 'wide': False, 'object': False, 'type': 'str'}, {'name': 'info', 'indirect': True, 'in': False, 'out': True, 'wide': False, 'object': False, 'type': 'vfs_fs_probe_info_t'}] */

	case _vfs_instance_op_fsprobe:
	{
		// TODO: check message type and detect protocol mismatch
			if (offsetof(typeof(*ops), fsprobe) + sizeof(void *) > ops_size || !ops->fsprobe) {
				ipcb_answer_protocol_error(msg);
				return;
			}

		service_id_t service_id = ipcb_get_val2(&msg);
		size_t fs_name_slice = ipcb_get_val_3(&msg);
		size_t fs_name_len = ipcb_slice_len(fs_name_slice);
		void *fs_name = calloc(fs_name_len, 1);
		if (fs_name == nullptr) {
			ipcb_answer_nomem(msg);
			return;
		}

		ipc_blob_read_4(&msg, fs_name, fs_name_slice);
		fs_name[fs_name_len - 1] = '\0';

		vfs_fs_probe_info_t info;
		errno_t rc = ops->fsprobe(self, service_id, fs_name, &info);
		ipcb_message_t answer = ipcb_start_answer(&msg, rc);

		struct __attribute__((packed)) {
			vfs_fs_probe_info_t info;
		} _outdata = {
			.info = info,
		};
		ipc_blob_write_1(&answer, &_outdata, sizeof(_outdata));

		ipcb_send_answer(&msg, answer);
		free(fs_name);
		return;
	}

	/* fstypes :: [{'name': 'fstypes', 'indirect': True, 'in': False, 'out': True, 'wide': False, 'object': False, 'type': None}] */

	case _vfs_instance_op_fstypes:
	{
		// TODO: check message type and detect protocol mismatch
			if (offsetof(typeof(*ops), fstypes) + sizeof(void *) > ops_size || !ops->fstypes) {
				ipcb_answer_protocol_error(msg);
				return;
			}

		size_t fstypes_slice = ipcb_get_val_2(&msg);
		size_t fstypes_len = ipcb_slice_len(fstypes_slice);
		void *fstypes = calloc(fstypes_len, 1);
		if (fstypes == nullptr) {
			ipcb_answer_nomem(msg);
			return;
		}

		ipcb_buffer_t fstypes_obj = ipc_get_obj_3(msg);

		errno_t rc = ops->fstypes(self, fstypes, fstypes_len);
		ipcb_buffer_write(fstypes_obj, fstypes_slice, fstypes, fstypes_len);
		ipcb_message_t answer = ipcb_start_answer(&msg, rc);
		ipcb_send_answer(&msg, answer);
		free(fstypes);
		return;
	}

	/* mount :: [{'name': 'mpfd', 'indirect': False, 'in': True, 'out': False, 'wide': False, 'object': False, 'type': 'int'}, {'name': 'service_id', 'indirect': False, 'in': True, 'out': False, 'wide': False, 'object': False, 'type': 'service_id_t'}, {'name': 'flags', 'indirect': False, 'in': True, 'out': False, 'wide': False, 'object': False, 'type': 'unsigned'}, {'name': 'instance', 'indirect': False, 'in': True, 'out': False, 'wide': False, 'object': False, 'type': 'unsigned'}, {'name': 'opts', 'indirect': True, 'in': True, 'out': False, 'wide': False, 'object': False, 'type': 'str'}, {'name': 'fs_name', 'indirect': True, 'in': True, 'out': False, 'wide': False, 'object': False, 'type': 'str'}, {'name': 'outfd', 'indirect': False, 'in': False, 'out': True, 'wide': False, 'object': False, 'type': 'int'}] */

	case _vfs_instance_op_mount:
	{
		// TODO: check message type and detect protocol mismatch
			if (offsetof(typeof(*ops), mount) + sizeof(void *) > ops_size || !ops->mount) {
				ipcb_answer_protocol_error(msg);
				return;
			}

		struct __attribute__((packed)) {
			int mpfd;
			service_id_t service_id;
			unsigned flags;
			unsigned instance;
			size_t opts_slice;
			size_t fs_name_slice;
		} _indata;

		ipc_blob_read_2(&msg, &_indata, sizeof(_indata));

		size_t opts_len = ipcb_slice_len(_indata.opts_slice);
		void *opts = calloc(opts_len, 1);
		if (opts == nullptr) {
			ipcb_answer_nomem(msg);
			return;
		}

		ipc_blob_read_3(&msg, opts, opts_slice);
		opts[opts_len - 1] = '\0';

		size_t fs_name_len = ipcb_slice_len(_indata.fs_name_slice);
		void *fs_name = calloc(fs_name_len, 1);
		if (fs_name == nullptr) {
			ipcb_answer_nomem(msg);
			free(opts);
			return;
		}

		ipc_blob_read_4(&msg, fs_name, fs_name_slice);
		fs_name[fs_name_len - 1] = '\0';

		int outfd;
		errno_t rc = ops->mount(self, _indata.mpfd, _indata.service_id, _indata.flags, _indata.instance, opts, fs_name, &outfd);
		ipcb_message_t answer = ipcb_start_answer(&msg, rc);
		ipcb_set_val_1(&answer, outfd);
		ipcb_send_answer(&msg, answer);
		free(opts);
		free(fs_name);
		return;
	}

	/* open :: [{'name': 'fd', 'indirect': False, 'in': True, 'out': False, 'wide': False, 'object': False, 'type': 'int'}, {'name': 'mode', 'indirect': False, 'in': True, 'out': False, 'wide': False, 'object': False, 'type': 'int'}] */

	case _vfs_instance_op_open:
	{
		// TODO: check message type and detect protocol mismatch
			if (offsetof(typeof(*ops), open) + sizeof(void *) > ops_size || !ops->open) {
				ipcb_answer_protocol_error(msg);
				return;
			}

		int fd = ipcb_get_val2(&msg);
		int mode = ipcb_get_val3(&msg);
		errno_t rc = ops->open(self, fd, mode);
		ipcb_message_t answer = ipcb_start_answer(&msg, rc);
		ipcb_send_answer(&msg, answer);
		return;
	}

	/* put :: [{'name': 'fd', 'indirect': False, 'in': True, 'out': False, 'wide': False, 'object': False, 'type': 'int'}] */

	case _vfs_instance_op_put:
	{
		// TODO: check message type and detect protocol mismatch
			if (offsetof(typeof(*ops), put) + sizeof(void *) > ops_size || !ops->put) {
				ipcb_answer_protocol_error(msg);
				return;
			}

		int fd = ipcb_get_val2(&msg);
		errno_t rc = ops->put(self, fd);
		ipcb_message_t answer = ipcb_start_answer(&msg, rc);
		ipcb_send_answer(&msg, answer);
		return;
	}

	/* read :: [{'name': 'fd', 'indirect': False, 'in': True, 'out': False, 'wide': False, 'object': False, 'type': 'int'}, {'name': 'pos', 'indirect': False, 'in': True, 'out': False, 'wide': True, 'object': False, 'type': 'aoff64_t'}, {'name': 'buffer', 'indirect': True, 'in': False, 'out': True, 'wide': False, 'object': False, 'type': None}, {'name': 'read', 'indirect': False, 'in': False, 'out': True, 'wide': False, 'object': False, 'type': 'size_t'}] */

	case _vfs_instance_op_read:
	{
		// TODO: check message type and detect protocol mismatch
			if (offsetof(typeof(*ops), read) + sizeof(void *) > ops_size || !ops->read) {
				ipcb_answer_protocol_error(msg);
				return;
			}

		struct __attribute__((packed)) {
			int fd;
			aoff64_t pos;
			size_t buffer_slice;
		} _indata;

		ipc_blob_read_2(&msg, &_indata, sizeof(_indata));

		size_t buffer_len = ipcb_slice_len(_indata.buffer_slice);
		void *buffer = calloc(buffer_len, 1);
		if (buffer == nullptr) {
			ipcb_answer_nomem(msg);
			return;
		}

		ipcb_buffer_t buffer_obj = ipc_get_obj_3(msg);

		size_t read;
		errno_t rc = ops->read(self, _indata.fd, _indata.pos, buffer, buffer_len, &read);
		ipcb_buffer_write(buffer_obj, _indata.buffer_slice, buffer, buffer_len);
		ipcb_message_t answer = ipcb_start_answer(&msg, rc);
		ipcb_set_val_1(&answer, read);
		ipcb_send_answer(&msg, answer);
		free(buffer);
		return;
	}

	/* rename :: [{'name': 'basefd', 'indirect': False, 'in': True, 'out': False, 'wide': False, 'object': False, 'type': 'int'}, {'name': 'old', 'indirect': True, 'in': True, 'out': False, 'wide': False, 'object': False, 'type': 'str'}, {'name': 'new', 'indirect': True, 'in': True, 'out': False, 'wide': False, 'object': False, 'type': 'str'}] */

	case _vfs_instance_op_rename:
	{
		// TODO: check message type and detect protocol mismatch
			if (offsetof(typeof(*ops), rename) + sizeof(void *) > ops_size || !ops->rename) {
				ipcb_answer_protocol_error(msg);
				return;
			}

		struct __attribute__((packed)) {
			int basefd;
			size_t old_slice;
			size_t new_slice;
		} _indata;

		ipc_blob_read_2(&msg, &_indata, sizeof(_indata));

		size_t old_len = ipcb_slice_len(_indata.old_slice);
		void *old = calloc(old_len, 1);
		if (old == nullptr) {
			ipcb_answer_nomem(msg);
			return;
		}

		ipc_blob_read_3(&msg, old, old_slice);
		old[old_len - 1] = '\0';

		size_t new_len = ipcb_slice_len(_indata.new_slice);
		void *new = calloc(new_len, 1);
		if (new == nullptr) {
			ipcb_answer_nomem(msg);
			free(old);
			return;
		}

		ipc_blob_read_4(&msg, new, new_slice);
		new[new_len - 1] = '\0';

		errno_t rc = ops->rename(self, _indata.basefd, old, new);
		ipcb_message_t answer = ipcb_start_answer(&msg, rc);
		ipcb_send_answer(&msg, answer);
		free(old);
		free(new);
		return;
	}

	/* resize :: [{'name': 'fd', 'indirect': False, 'in': True, 'out': False, 'wide': False, 'object': False, 'type': 'int'}, {'name': 'size', 'indirect': False, 'in': True, 'out': False, 'wide': True, 'object': False, 'type': 'int64_t'}] */

	case _vfs_instance_op_resize:
	{
		// TODO: check message type and detect protocol mismatch
			if (offsetof(typeof(*ops), resize) + sizeof(void *) > ops_size || !ops->resize) {
				ipcb_answer_protocol_error(msg);
				return;
			}

		int fd = ipcb_get_val2(&msg);
		int64_t size = ipcb_get_val64_3(&msg);
		errno_t rc = ops->resize(self, fd, size);
		ipcb_message_t answer = ipcb_start_answer(&msg, rc);
		ipcb_send_answer(&msg, answer);
		return;
	}

	/* stat :: [{'name': 'fd', 'indirect': False, 'in': True, 'out': False, 'wide': False, 'object': False, 'type': 'int'}, {'name': 'data', 'indirect': True, 'in': False, 'out': True, 'wide': False, 'object': False, 'type': 'vfs_stat_t'}] */

	case _vfs_instance_op_stat:
	{
		// TODO: check message type and detect protocol mismatch
			if (offsetof(typeof(*ops), stat) + sizeof(void *) > ops_size || !ops->stat) {
				ipcb_answer_protocol_error(msg);
				return;
			}

		int fd = ipcb_get_val2(&msg);
		vfs_stat_t data;
		errno_t rc = ops->stat(self, fd, &data);
		ipcb_message_t answer = ipcb_start_answer(&msg, rc);

		struct __attribute__((packed)) {
			vfs_stat_t data;
		} _outdata = {
			.data = data,
		};
		ipc_blob_write_1(&answer, &_outdata, sizeof(_outdata));

		ipcb_send_answer(&msg, answer);
		return;
	}

	/* statfs :: [{'name': 'fd', 'indirect': False, 'in': True, 'out': False, 'wide': False, 'object': False, 'type': 'int'}, {'name': 'data', 'indirect': True, 'in': False, 'out': True, 'wide': False, 'object': False, 'type': 'vfs_statfs_t'}] */

	case _vfs_instance_op_statfs:
	{
		// TODO: check message type and detect protocol mismatch
			if (offsetof(typeof(*ops), statfs) + sizeof(void *) > ops_size || !ops->statfs) {
				ipcb_answer_protocol_error(msg);
				return;
			}

		int fd = ipcb_get_val2(&msg);
		vfs_statfs_t data;
		errno_t rc = ops->statfs(self, fd, &data);
		ipcb_message_t answer = ipcb_start_answer(&msg, rc);

		struct __attribute__((packed)) {
			vfs_statfs_t data;
		} _outdata = {
			.data = data,
		};
		ipc_blob_write_1(&answer, &_outdata, sizeof(_outdata));

		ipcb_send_answer(&msg, answer);
		return;
	}

	/* sync :: [{'name': 'fd', 'indirect': False, 'in': True, 'out': False, 'wide': False, 'object': False, 'type': 'int'}] */

	case _vfs_instance_op_sync:
	{
		// TODO: check message type and detect protocol mismatch
			if (offsetof(typeof(*ops), sync) + sizeof(void *) > ops_size || !ops->sync) {
				ipcb_answer_protocol_error(msg);
				return;
			}

		int fd = ipcb_get_val2(&msg);
		errno_t rc = ops->sync(self, fd);
		ipcb_message_t answer = ipcb_start_answer(&msg, rc);
		ipcb_send_answer(&msg, answer);
		return;
	}

	/* unlink :: [{'name': 'parentfd', 'indirect': False, 'in': True, 'out': False, 'wide': False, 'object': False, 'type': 'int'}, {'name': 'expectfd', 'indirect': False, 'in': True, 'out': False, 'wide': False, 'object': False, 'type': 'int'}, {'name': 'path', 'indirect': True, 'in': True, 'out': False, 'wide': False, 'object': False, 'type': 'str'}] */

	case _vfs_instance_op_unlink:
	{
		// TODO: check message type and detect protocol mismatch
			if (offsetof(typeof(*ops), unlink) + sizeof(void *) > ops_size || !ops->unlink) {
				ipcb_answer_protocol_error(msg);
				return;
			}

		int parentfd = ipcb_get_val2(&msg);
		int expectfd = ipcb_get_val3(&msg);
		size_t path_slice = ipcb_get_val_4(&msg);
		size_t path_len = ipcb_slice_len(path_slice);
		void *path = calloc(path_len, 1);
		if (path == nullptr) {
			ipcb_answer_nomem(msg);
			return;
		}

		ipc_blob_read_5(&msg, path, path_slice);
		path[path_len - 1] = '\0';

		errno_t rc = ops->unlink(self, parentfd, expectfd, path);
		ipcb_message_t answer = ipcb_start_answer(&msg, rc);
		ipcb_send_answer(&msg, answer);
		free(path);
		return;
	}

	/* unmount :: [{'name': 'mpfd', 'indirect': False, 'in': True, 'out': False, 'wide': False, 'object': False, 'type': 'int'}] */

	case _vfs_instance_op_unmount:
	{
		// TODO: check message type and detect protocol mismatch
			if (offsetof(typeof(*ops), unmount) + sizeof(void *) > ops_size || !ops->unmount) {
				ipcb_answer_protocol_error(msg);
				return;
			}

		int mpfd = ipcb_get_val2(&msg);
		errno_t rc = ops->unmount(self, mpfd);
		ipcb_message_t answer = ipcb_start_answer(&msg, rc);
		ipcb_send_answer(&msg, answer);
		return;
	}

	/* wrap_handle :: [{'name': 'fd', 'indirect': False, 'in': True, 'out': False, 'wide': False, 'object': False, 'type': 'int'}, {'name': 'handle', 'indirect': True, 'in': False, 'out': True, 'wide': False, 'object': True, 'type': 'vfs_wrapped_handle'}] */

	case _vfs_instance_op_wrap_handle:
	{
		// TODO: check message type and detect protocol mismatch
			if (offsetof(typeof(*ops), wrap_handle) + sizeof(void *) > ops_size || !ops->wrap_handle) {
				ipcb_answer_protocol_error(msg);
				return;
			}

		int fd = ipcb_get_val2(&msg);
		vfs_wrapped_handle handle;
		errno_t rc = ops->wrap_handle(self, fd, &handle);
		ipcb_message_t answer = ipcb_start_answer(&msg, rc);

		struct __attribute__((packed)) {
			vfs_wrapped_handle handle;
		} _outdata = {
			.handle = handle,
		};
		ipc_blob_write_1(&answer, &_outdata, sizeof(_outdata));

		ipcb_send_answer(&msg, answer);
		return;
	}

	/* unwrap_handle :: [{'name': 'handle', 'indirect': True, 'in': True, 'out': False, 'wide': False, 'object': True, 'type': 'vfs_wrapped_handle'}, {'name': 'high_fd', 'indirect': False, 'in': True, 'out': False, 'wide': False, 'object': False, 'type': 'bool'}, {'name': 'fd', 'indirect': False, 'in': False, 'out': True, 'wide': False, 'object': False, 'type': 'int'}] */

	case _vfs_instance_op_unwrap_handle:
	{
		// TODO: check message type and detect protocol mismatch
			if (offsetof(typeof(*ops), unwrap_handle) + sizeof(void *) > ops_size || !ops->unwrap_handle) {
				ipcb_answer_protocol_error(msg);
				return;
			}

		struct __attribute__((packed)) {
			vfs_wrapped_handle handle;
		} _indata;

		ipc_blob_read_2(&msg, &_indata, sizeof(_indata));

		vfs_wrapped_handle handle = ipcb_get_obj3(&msg);
		bool high_fd = ipcb_get_val4(&msg);
		vfs_wrapped_handle handle = _indata.handle;
		int fd;
		errno_t rc = ops->unwrap_handle(self, &handle, high_fd, &fd);
		ipcb_message_t answer = ipcb_start_answer(&msg, rc);
		ipcb_set_val_1(&answer, fd);
		ipcb_send_answer(&msg, answer);
		return;
	}

	/* walk :: [{'name': 'parentfd', 'indirect': False, 'in': True, 'out': False, 'wide': False, 'object': False, 'type': 'int'}, {'name': 'flags', 'indirect': False, 'in': True, 'out': False, 'wide': False, 'object': False, 'type': 'int'}, {'name': 'path', 'indirect': True, 'in': True, 'out': False, 'wide': False, 'object': False, 'type': 'str'}, {'name': 'fd', 'indirect': False, 'in': False, 'out': True, 'wide': False, 'object': False, 'type': 'int'}] */

	case _vfs_instance_op_walk:
	{
		// TODO: check message type and detect protocol mismatch
			if (offsetof(typeof(*ops), walk) + sizeof(void *) > ops_size || !ops->walk) {
				ipcb_answer_protocol_error(msg);
				return;
			}

		int parentfd = ipcb_get_val2(&msg);
		int flags = ipcb_get_val3(&msg);
		size_t path_slice = ipcb_get_val_4(&msg);
		size_t path_len = ipcb_slice_len(path_slice);
		void *path = calloc(path_len, 1);
		if (path == nullptr) {
			ipcb_answer_nomem(msg);
			return;
		}

		ipc_blob_read_5(&msg, path, path_slice);
		path[path_len - 1] = '\0';

		int fd;
		errno_t rc = ops->walk(self, parentfd, flags, path, &fd);
		ipcb_message_t answer = ipcb_start_answer(&msg, rc);
		ipcb_set_val_1(&answer, fd);
		ipcb_send_answer(&msg, answer);
		free(path);
		return;
	}

	/* write :: [{'name': 'fd', 'indirect': False, 'in': True, 'out': False, 'wide': False, 'object': False, 'type': 'int'}, {'name': 'pos', 'indirect': False, 'in': True, 'out': False, 'wide': True, 'object': False, 'type': 'aoff64_t'}, {'name': 'buffer', 'indirect': True, 'in': True, 'out': False, 'wide': False, 'object': False, 'type': None}, {'name': 'written', 'indirect': False, 'in': False, 'out': True, 'wide': False, 'object': False, 'type': 'size_t'}] */

	case _vfs_instance_op_write:
	{
		// TODO: check message type and detect protocol mismatch
			if (offsetof(typeof(*ops), write) + sizeof(void *) > ops_size || !ops->write) {
				ipcb_answer_protocol_error(msg);
				return;
			}

		struct __attribute__((packed)) {
			int fd;
			aoff64_t pos;
			size_t buffer_slice;
		} _indata;

		ipc_blob_read_2(&msg, &_indata, sizeof(_indata));

		size_t buffer_len = ipcb_slice_len(_indata.buffer_slice);
		void *buffer = calloc(buffer_len, 1);
		if (buffer == nullptr) {
			ipcb_answer_nomem(msg);
			return;
		}

		ipc_blob_read_3(&msg, buffer, buffer_slice);

		size_t written;
		errno_t rc = ops->write(self, _indata.fd, _indata.pos, buffer, buffer_len, &written);
		ipcb_message_t answer = ipcb_start_answer(&msg, rc);
		ipcb_set_val_1(&answer, written);
		ipcb_send_answer(&msg, answer);
		free(buffer);
		return;
	}
	default:
		ipcb_answer_protocol_error(msg);
	}
}
